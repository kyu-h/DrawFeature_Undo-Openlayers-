{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///bundle.min.js","webpack:///webpack/bootstrap de4fe9d7d747c6eb089c","webpack:///./src/index.js","webpack:///./src/RotateFeatureEvent.js","webpack:///./src/RotateFeatureInteraction.js","webpack:///./src/util.js","webpack:///external {\"root\":\"ol\",\"amd\":\"openlayers\",\"commonjs\":\"openlayers\",\"commonjs2\":\"openlayers\"}"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_4__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_RotateFeatureInteraction","_RotateFeatureInteraction2","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","RotateFeatureEventType","START","ROTATING","END","RotateFeatureEvent","type","features","angle","anchor","propagationStopped","undefined","_defineProperty","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","handleDownEvent","evt","foundFeature","map","forEachFeatureAtPixel","pixel","feature","lastCoordinate_","features_","getArray","includes","arrowFeature_","anchorFeature_","anchorMoving_","handleMoveEvent","coordinate","dispatchRotateStartEvent_","handleUpEvent","dispatchRotateEndEvent_","handleDragEvent","newCoordinate","anchorCoordinate","getGeometry","getCoordinates","lastVector","newVector","Math","atan2","setAngle","getAngle","dispatchRotatingEvent_","setAnchor","elem","getTargetElement","setCursor","cursor","vendor","arguments","style","previousCursor_","getDefaultStyle","_styles","white","blue","transparent","width","styles","ANCHOR_KEY","_openlayers2","Style","image","RegularShape","fill","Fill","color","stroke","Stroke","radius","points","zIndex","Infinity","ARROW_KEY","text","Text","font","offsetX","offsetY","resolution","get","ANGLE_PROP","getImage","setRotation","coordinates","geom","Polygon","rotate","setGeometry","getText","setText","round","PI","getFeaturesExtent","getLength","GeometryCollection","Array","isArray","getExtent","getFeaturesCentroid","extent","getCenter","_get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","getter","_openlayers","_util","_RotateFeatureEvent","ANCHOR_PROP","RotateFeatureInteraction","_ol$interaction$Point","options","_this","handleEvent","assertInstanceOf","Collection","overlay_","layer","Vector","source","on","onFeatureAdd_","onFeatureRemove_","onChangeActive_","onAngleChange_","onAnchorChange_","setMap","updateInteractionFeatures_","reset_","getActive","assert","isNaN","parseFloat","set","coalesce","createOrUpdateAnchorFeature_","createOrUpdateArrowFeature_","_this2","resetAngleAndAnchor","resetAngleAndAnchor_","forEach","getSource","removeFeature","resetAngle_","resetAnchor_","getAnchor","setCoordinates","_ref","Feature","geometry","Point","addFeature","_ref2","_ref3","element","_ref4","_ref5","_this3","oldValue","dispatchEvent","interaction","Pointer","condition","message","join","Error","getValueType","noop","identity","arg","name","toString","_typeof","_len","values","_key","find","Symbol","iterator"],"mappings":"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","file":"bundle.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"openlayers\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"openlayers\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"RotateFeature\"] = factory(require(\"openlayers\"));\n\telse\n\t\troot[\"ol\"] = root[\"ol\"] || {}, root[\"ol\"][\"interaction\"] = root[\"ol\"][\"interaction\"] || {}, root[\"ol\"][\"interaction\"][\"RotateFeature\"] = factory(root[\"ol\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_4__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*!\n * OpenLayers 3 interaction that allows to rotate vector features\n * \n * @package ol3-rotate-feature\n * @author Vladimir Vershinin <ghettovoice@gmail.com>\n * @version 1.2.2\n * @licence MIT https://opensource.org/licenses/MIT\n *          Based on OpenLayers 3. Copyright 2005-2016 OpenLayers Contributors. All rights reserved. http://openlayers.org\n * @copyright (c) 2016, Vladimir Vershinin <ghettovoice@gmail.com>\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"openlayers\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"openlayers\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"RotateFeature\"] = factory(require(\"openlayers\"));\n\telse\n\t\troot[\"ol\"] = root[\"ol\"] || {}, root[\"ol\"][\"interaction\"] = root[\"ol\"][\"interaction\"] || {}, root[\"ol\"][\"interaction\"][\"RotateFeature\"] = factory(root[\"ol\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_4__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _RotateFeatureInteraction = __webpack_require__(2);\n\t\n\tvar _RotateFeatureInteraction2 = _interopRequireDefault(_RotateFeatureInteraction);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\texports.default = _RotateFeatureInteraction2.default; /**\n\t                                                       * OpenLayers 3 rotate interaction.\n\t                                                       * Allows vector feature rotation.\n\t                                                       *\n\t                                                       * @author Vladimir Vershinin <ghettovoice@gmail.com>\n\t                                                       * @licence MIT https://opensource.org/licenses/MIT\n\t                                                       *          Based on OpenLayers 3. Copyright 2005-2015 OpenLayers Contributors. All rights reserved. http://openlayers.org\n\t                                                       * @copyright (c) 2016, Vladimir Vershinin\n\t                                                       */\n\n\tmodule.exports = exports[\"default\"];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * @enum {string}\n\t */\n\tvar RotateFeatureEventType = exports.RotateFeatureEventType = {\n\t  /**\n\t   * Triggered upon feature rotate start.\n\t   * @event RotateFeatureEvent#rotatestart\n\t   */\n\t  START: 'rotatestart',\n\t  /**\n\t   * Triggered upon feature rotation.\n\t   * @event RotateFeatureEvent#rotating\n\t   */\n\t  ROTATING: 'rotating',\n\t  /**\n\t   * Triggered upon feature rotation end.\n\t   * @event RotateFeatureEvent#rotateend\n\t   */\n\t  END: 'rotateend'\n\t};\n\t\n\t/**\n\t * Events emitted by RotateFeatureInteraction instances are instances of this type.\n\t *\n\t * @class\n\t * @author Vladimir Vershinin\n\t */\n\t\n\tvar RotateFeatureEvent = exports.RotateFeatureEvent = function () {\n\t  /**\n\t   * @param {RotateFeatureEventType} type Type.\n\t   * @param {ol.Collection<ol.Feature>} features Rotated features.\n\t   * @param {number} angle Angle in radians.\n\t   * @param {ol.Coordinate} anchor Anchor position.\n\t   */\n\t\n\t  function RotateFeatureEvent(type, features, angle, anchor) {\n\t    _classCallCheck(this, RotateFeatureEvent);\n\t\n\t    /**\n\t     * @type {boolean}\n\t     */\n\t    this.propagationStopped = undefined;\n\t\n\t    /**\n\t     * The event type.\n\t     * @type {RotateFeatureEventType}\n\t     */\n\t    this.type = type;\n\t\n\t    /**\n\t     * The features being rotated.\n\t     * @type {ol.Collection<ol.Feature>}\n\t     */\n\t    this.features = features;\n\t    /**\n\t     * Current angle in radians.\n\t     * @type {number}\n\t     */\n\t    this.angle = angle;\n\t    /**\n\t     * Current rotation anchor.\n\t     * @type {number[] | ol.Coordinate}\n\t     */\n\t    this.anchor = anchor;\n\t  }\n\t\n\t  /**\n\t   * Stop event propagation.\n\t   * @function\n\t   */\n\t\n\t\n\t  _createClass(RotateFeatureEvent, [{\n\t    key: 'preventDefault',\n\t    value: function preventDefault() {\n\t      this.propagationStopped = true;\n\t    }\n\t\n\t    /**\n\t     * Stop event propagation.\n\t     * @function\n\t     */\n\t\n\t  }, {\n\t    key: 'stopPropagation',\n\t    value: function stopPropagation() {\n\t      this.propagationStopped = true;\n\t    }\n\t  }]);\n\n\t  return RotateFeatureEvent;\n\t}();\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _openlayers = __webpack_require__(4);\n\t\n\tvar _openlayers2 = _interopRequireDefault(_openlayers);\n\t\n\tvar _util = __webpack_require__(3);\n\t\n\tvar _RotateFeatureEvent = __webpack_require__(1);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t/**\n\t * @typedef {Object} InteractionOptions\n\t * @property {ol.Collection<ol.Feature>} features The features the interaction works on. Required.\n\t * @property {ol.style.Style | Array<ol.style.Style> | ol.style.StyleFunction | undefined} style  Style of the overlay.\n\t * @property {number | undefined} angle Initial angle in radians (positive is counter-clockwise),\n\t *                                      applied for features already added to collection. Default is `0`.\n\t * @property {number[] | ol.Coordinate | undefined} anchor Initial anchor coordinate. Default is center of features extent.\n\t */\n\tvar InteractionOptions;\n\t\n\tvar ANCHOR_KEY = 'anchor';\n\tvar ARROW_KEY = 'arrow';\n\t// const GHOST_KEY = 'ghost';\n\t\n\tvar ANGLE_PROP = 'angle';\n\tvar ANCHOR_PROP = 'anchor';\n\t\n\t/**\n\t * todo добавить опцию condition - для возможности переопределения клавиш\n\t *\n\t * Rotate interaction class.\n\t * Adds controls to rotate vector features.\n\t * Writes out total angle in radians (positive is counter-clockwise) to property for each feature.\n\t *\n\t * @author Vladimir Vershinin\n\t */\n\t\n\tvar RotateFeatureInteraction = function (_ol$interaction$Point) {\n\t    _inherits(RotateFeatureInteraction, _ol$interaction$Point);\n\t\n\t    /**\n\t     * @param {InteractionOptions} options\n\t     */\n\t\n\t    function RotateFeatureInteraction() {\n\t        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\n\t        _classCallCheck(this, RotateFeatureInteraction);\n\t\n\t        var _this = _possibleConstructorReturn(this, (RotateFeatureInteraction.__proto__ || Object.getPrototypeOf(RotateFeatureInteraction)).call(this, {\n\t            handleEvent: RotateFeatureInteraction.handleEvent,\n\t            handleDownEvent: handleDownEvent,\n\t            handleUpEvent: handleUpEvent,\n\t            handleDragEvent: handleDragEvent,\n\t            handleMoveEvent: handleMoveEvent\n\t        }));\n\t\n\t        if (options.angle != null) {\n\t            _this.setAngle(options.angle);\n\t        }\n\t\n\t        if (options.anchor != null) {\n\t            _this.setAnchor(options.anchor);\n\t        }\n\t\n\t        /**\n\t         * @type {ol.Collection.<ol.Feature>}\n\t         * @private\n\t         */\n\t        _this.features_ = options.features;\n\t\n\t        (0, _util.assertInstanceOf)(_this.features_, _openlayers2.default.Collection);\n\t\n\t        /**\n\t         * @type {ol.layer.Vector}\n\t         * @private\n\t         */\n\t        _this.overlay_ = new _openlayers2.default.layer.Vector({\n\t            style: options.style || getDefaultStyle(),\n\t            source: new _openlayers2.default.source.Vector({\n\t                features: new _openlayers2.default.Collection()\n\t            })\n\t        });\n\t        /**\n\t         * @type {string}\n\t         * @private\n\t         */\n\t        _this.previousCursor_ = undefined;\n\t        //        /**\n\t        //         * Rotated feature.\n\t        //         *\n\t        //         * @type {ol.Feature}\n\t        //         * @private\n\t        //         */\n\t        //        this.ghostFeature_ = undefined;\n\t        /**\n\t         * @type {ol.Feature}\n\t         * @private\n\t         */\n\t        _this.anchorFeature_ = undefined;\n\t        /**\n\t         * @type {ol.Feature}\n\t         * @private\n\t         */\n\t        _this.arrowFeature_ = undefined;\n\t        /**\n\t         * @type {ol.Coordinate}\n\t         * @private\n\t         */\n\t        _this.lastCoordinate_ = undefined;\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        _this.anchorMoving_ = false;\n\t\n\t        _this.features_.on('add', _this.onFeatureAdd_, _this);\n\t        _this.features_.on('remove', _this.onFeatureRemove_, _this);\n\t\n\t        _this.on('change:active', _this.onChangeActive_, _this);\n\t        _this.on('change:' + ANGLE_PROP, _this.onAngleChange_, _this);\n\t        _this.on('change:' + ANCHOR_PROP, _this.onAnchorChange_, _this);\n\t        return _this;\n\t    }\n\t\n\t    /**\n\t     * @param {ol.MapBrowserEvent} evt Map browser event.\n\t     * @return {boolean} `false` to stop event propagation.\n\t     * @this {RotateFeatureInteraction}\n\t     * @public\n\t     */\n\t\n\t\n\t    _createClass(RotateFeatureInteraction, [{\n\t        key: \"setMap\",\n\t\n\t\n\t        //noinspection JSUnusedGlobalSymbols\n\t        /**\n\t         * @param {ol.Map} map\n\t         */\n\t        value: function setMap(map) {\n\t            this.overlay_.setMap(map);\n\t            _get(RotateFeatureInteraction.prototype.__proto__ || Object.getPrototypeOf(RotateFeatureInteraction.prototype), \"setMap\", this).call(this, map);\n\t\n\t            if (map) {\n\t                this.updateInteractionFeatures_();\n\t            } else {\n\t                this.reset_(true);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: \"onChangeActive_\",\n\t        value: function onChangeActive_() {\n\t            if (this.getActive()) {\n\t                this.updateInteractionFeatures_();\n\t            } else {\n\t                this.reset_(true);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Set current angle of interaction features.\n\t         *\n\t         * @param {number} angle\n\t         */\n\t\n\t    }, {\n\t        key: \"setAngle\",\n\t        value: function setAngle(angle) {\n\t            (0, _util.assert)(!isNaN(parseFloat(angle)), 'Numeric value passed');\n\t\n\t            this.set(ANGLE_PROP, parseFloat(angle));\n\t        }\n\t\n\t        /**\n\t         * Returns current angle of interaction features.\n\t         *\n\t         * @return {number}\n\t         */\n\t\n\t    }, {\n\t        key: \"getAngle\",\n\t        value: function getAngle() {\n\t            return (0, _util.coalesce)(this.get(ANGLE_PROP), 0);\n\t        }\n\t\n\t        /**\n\t         * Set current anchor position.\n\t         *\n\t         * @param {number[] | ol.Coordinate | undefined} anchor\n\t         */\n\t\n\t    }, {\n\t        key: \"setAnchor\",\n\t        value: function setAnchor(anchor) {\n\t            (0, _util.assert)(anchor == null || Array.isArray(anchor) && anchor.length === 2, 'Array of two elements passed');\n\t            this.set(ANCHOR_PROP, anchor != null ? anchor.map(parseFloat) : undefined);\n\t        }\n\t\n\t        /**\n\t         * Returns current anchor position.\n\t         *\n\t         * @return {number[] | ol.Coordinate | undefined}\n\t         */\n\t\n\t    }, {\n\t        key: \"getAnchor\",\n\t        value: function getAnchor() {\n\t            return (0, _util.coalesce)(this.get(ANCHOR_PROP), getFeaturesCentroid(this.features_));\n\t        }\n\t\n\t        /**\n\t         * Creates or updates all interaction helper features.\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: \"updateInteractionFeatures_\",\n\t        value: function updateInteractionFeatures_() {\n\t            if (!this.features_.getLength()) {\n\t                this.reset_();\n\t\n\t                return;\n\t            }\n\t\n\t            this.createOrUpdateAnchorFeature_();\n\t            this.createOrUpdateArrowFeature_();\n\t        }\n\t\n\t        /**\n\t         * @param {boolean} [resetAngleAndAnchor]\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: \"reset_\",\n\t        value: function reset_() {\n\t            var _this2 = this;\n\t\n\t            var resetAngleAndAnchor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t\n\t            if (resetAngleAndAnchor) {\n\t                this.resetAngleAndAnchor_();\n\t            }\n\t\n\t            [this.anchorFeature_, this.arrowFeature_].forEach(function (feature) {\n\t                if (feature) {\n\t                    _this2.overlay_.getSource().removeFeature(feature);\n\t                }\n\t            });\n\t\n\t            this.anchorFeature_ = this.arrowFeature_ = this.lastCoordinate_ = undefined;\n\t            this.anchorMoving_ = false;\n\t        }\n\t\n\t        /**\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: \"resetAngleAndAnchor_\",\n\t        value: function resetAngleAndAnchor_() {\n\t            this.resetAngle_();\n\t            this.resetAnchor_();\n\t        }\n\t\n\t        /**\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: \"resetAngle_\",\n\t        value: function resetAngle_() {\n\t            this.set(ANGLE_PROP, 0, true);\n\t            this.arrowFeature_ && this.arrowFeature_.set(ANGLE_PROP, this.getAngle());\n\t            this.anchorFeature_ && this.anchorFeature_.set(ANGLE_PROP, this.getAngle());\n\t        }\n\t\n\t        /**\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: \"resetAnchor_\",\n\t        value: function resetAnchor_() {\n\t            this.set(ANCHOR_PROP, getFeaturesCentroid(this.features_), true);\n\t\n\t            if (this.getAnchor()) {\n\t                this.arrowFeature_ && this.arrowFeature_.getGeometry().setCoordinates(this.getAnchor());\n\t                this.anchorFeature_ && this.anchorFeature_.getGeometry().setCoordinates(this.getAnchor());\n\t            }\n\t        }\n\t\n\t        /**\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: \"createOrUpdateAnchorFeature_\",\n\t        value: function createOrUpdateAnchorFeature_() {\n\t            var angle = this.getAngle();\n\t            var anchor = this.getAnchor();\n\t\n\t            if (this.anchorFeature_) {\n\t                this.anchorFeature_.getGeometry().setCoordinates(anchor);\n\t            } else {\n\t                var _ref;\n\t\n\t                this.anchorFeature_ = new _openlayers2.default.Feature((_ref = {\n\t                    geometry: new _openlayers2.default.geom.Point(anchor)\n\t                }, _defineProperty(_ref, ANCHOR_KEY, true), _defineProperty(_ref, ANGLE_PROP, angle), _ref));\n\t                this.overlay_.getSource().addFeature(this.anchorFeature_);\n\t            }\n\t        }\n\t\n\t        //    /**\n\t        //     * @private\n\t        //     */\n\t        //    createOrUpdateGhostFeature_() {\n\t        //        if (this.ghostFeature_) {\n\t        //            this.ghostFeature_.getGeometry().setGeometries(geometries);\n\t        //        } else {\n\t        //            this.ghostFeature_ = new ol.Feature({\n\t        //                geometry: new ol.geom.GeometryCollection(geometries),\n\t        //                [GHOST_KEY]: true\n\t        //            });\n\t        //            this.overlay_.addFeature(this.ghostFeature_);\n\t        //        }\n\t        //    }\n\t\n\t        /**\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: \"createOrUpdateArrowFeature_\",\n\t        value: function createOrUpdateArrowFeature_() {\n\t            var angle = this.getAngle();\n\t            var anchor = this.getAnchor();\n\t\n\t            if (this.arrowFeature_) {\n\t                this.arrowFeature_.getGeometry().setCoordinates(anchor);\n\t            } else {\n\t                var _ref2;\n\t\n\t                this.arrowFeature_ = new _openlayers2.default.Feature((_ref2 = {\n\t                    geometry: new _openlayers2.default.geom.Point(anchor)\n\t                }, _defineProperty(_ref2, ARROW_KEY, true), _defineProperty(_ref2, ANGLE_PROP, angle), _ref2));\n\t                this.overlay_.getSource().addFeature(this.arrowFeature_);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * @param {ol.Feature} element\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: \"onFeatureAdd_\",\n\t        value: function onFeatureAdd_(_ref3) {\n\t            var element = _ref3.element;\n\t\n\t            if (!this.getActive()) {\n\t                return;\n\t            }\n\t\n\t            (0, _util.assertInstanceOf)(element, _openlayers2.default.Feature);\n\t\n\t            this.resetAngleAndAnchor_();\n\t            this.updateInteractionFeatures_();\n\t        }\n\t\n\t        /**\n\t         * @param {ol.Feature} element\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: \"onFeatureRemove_\",\n\t        value: function onFeatureRemove_(_ref4) {\n\t            var element = _ref4.element;\n\t\n\t            if (!this.getActive()) {\n\t                return;\n\t            }\n\t\n\t            (0, _util.assertInstanceOf)(element, _openlayers2.default.Feature);\n\t\n\t            this.resetAngleAndAnchor_();\n\t            this.updateInteractionFeatures_();\n\t        }\n\t\n\t        /**\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: \"onAngleChange_\",\n\t        value: function onAngleChange_(_ref5) {\n\t            var _this3 = this;\n\t\n\t            var oldValue = _ref5.oldValue;\n\t\n\t            this.features_.forEach(function (feature) {\n\t                return feature.getGeometry().rotate(_this3.getAngle() - oldValue, _this3.anchorFeature_.getGeometry().getCoordinates());\n\t            });\n\t            this.arrowFeature_ && this.arrowFeature_.set(ANGLE_PROP, this.getAngle());\n\t            this.anchorFeature_ && this.anchorFeature_.set(ANGLE_PROP, this.getAngle());\n\t        }\n\t\n\t        /**\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: \"onAnchorChange_\",\n\t        value: function onAnchorChange_() {\n\t            var anchor = this.getAnchor();\n\t\n\t            if (anchor) {\n\t                this.anchorFeature_ && this.anchorFeature_.getGeometry().setCoordinates(anchor);\n\t                this.arrowFeature_ && this.arrowFeature_.getGeometry().setCoordinates(anchor);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * @param {ol.Collection<ol.Feature>} features\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: \"dispatchRotateStartEvent_\",\n\t        value: function dispatchRotateStartEvent_(features) {\n\t            this.dispatchEvent(new _RotateFeatureEvent.RotateFeatureEvent(_RotateFeatureEvent.RotateFeatureEventType.START, features, this.getAngle(), this.getAnchor()));\n\t        }\n\t\n\t        /**\n\t         * @param {ol.Collection<ol.Feature>} features\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: \"dispatchRotatingEvent_\",\n\t        value: function dispatchRotatingEvent_(features) {\n\t            this.dispatchEvent(new _RotateFeatureEvent.RotateFeatureEvent(_RotateFeatureEvent.RotateFeatureEventType.ROTATING, features, this.getAngle(), this.getAnchor()));\n\t        }\n\t\n\t        /**\n\t         * @param {ol.Collection<ol.Feature>} features\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: \"dispatchRotateEndEvent_\",\n\t        value: function dispatchRotateEndEvent_(features) {\n\t            this.dispatchEvent(new _RotateFeatureEvent.RotateFeatureEvent(_RotateFeatureEvent.RotateFeatureEventType.END, features, this.getAngle(), this.getAnchor()));\n\t        }\n\t    }], [{\n\t        key: \"handleEvent\",\n\t        value: function handleEvent(evt) {\n\t            // disable selection of inner features\n\t            var foundFeature = evt.map.forEachFeatureAtPixel(evt.pixel, function (feature) {\n\t                return feature;\n\t            });\n\t            if (['click', 'singleclick'].includes(evt.type) && foundFeature && [this.anchorFeature_, this.arrowFeature_].includes(foundFeature)) {\n\t                return false;\n\t            }\n\t\n\t            return _openlayers2.default.interaction.Pointer.handleEvent.call(this, evt);\n\t        }\n\t    }]);\n\t\n\t    return RotateFeatureInteraction;\n\t}(_openlayers2.default.interaction.Pointer);\n\t\n\t/**\n\t * @param {ol.MapBrowserEvent} evt Event.\n\t * @return {boolean}\n\t * @this {RotateFeatureInteraction}\n\t * @private\n\t */\n\t\n\t\n\texports.default = RotateFeatureInteraction;\n\tfunction handleDownEvent(evt) {\n\t    var foundFeature = evt.map.forEachFeatureAtPixel(evt.pixel, function (feature) {\n\t        return feature;\n\t    });\n\t\n\t    // handle click & drag on features for rotation\n\t    if (foundFeature && !this.lastCoordinate_ && (this.features_.getArray().includes(foundFeature) || foundFeature === this.arrowFeature_)) {\n\t        this.lastCoordinate_ = evt.coordinate;\n\t\n\t        handleMoveEvent.call(this, evt);\n\t        this.dispatchRotateStartEvent_(this.features_);\n\t\n\t        return true;\n\t    }\n\t    // handle click & drag on rotation anchor feature\n\t    else if (foundFeature && foundFeature === this.anchorFeature_) {\n\t            this.anchorMoving_ = true;\n\t            handleMoveEvent.call(this, evt);\n\t\n\t            return true;\n\t        }\n\t\n\t    return false;\n\t}\n\t\n\t/**\n\t * @param {ol.MapBrowserEvent} evt Event.\n\t * @return {boolean}\n\t * @this {RotateFeatureInteraction}\n\t * @private\n\t */\n\tfunction handleUpEvent(evt) {\n\t    // stop drag sequence of features\n\t    if (this.lastCoordinate_) {\n\t        this.lastCoordinate_ = undefined;\n\t\n\t        handleMoveEvent.call(this, evt);\n\t        this.dispatchRotateEndEvent_(this.features_);\n\t\n\t        return true;\n\t    }\n\t    // stop drag sequence of the anchors\n\t    else if (this.anchorMoving_) {\n\t            this.anchorMoving_ = false;\n\t            handleMoveEvent.call(this, evt);\n\t\n\t            return true;\n\t        }\n\t\n\t    return false;\n\t}\n\t\n\t/**\n\t * @param {ol.MapBrowserEvent} evt Event.\n\t * @return {boolean}\n\t * @this {RotateFeatureInteraction}\n\t * @private\n\t */\n\tfunction handleDragEvent(evt) {\n\t    var newCoordinate = evt.coordinate;\n\t    var anchorCoordinate = this.anchorFeature_.getGeometry().getCoordinates();\n\t\n\t    // handle drag of features by angle\n\t    if (this.lastCoordinate_) {\n\t        // calculate vectors of last and current pointer positions\n\t        var lastVector = [this.lastCoordinate_[0] - anchorCoordinate[0], this.lastCoordinate_[1] - anchorCoordinate[1]];\n\t        var newVector = [newCoordinate[0] - anchorCoordinate[0], newCoordinate[1] - anchorCoordinate[1]];\n\t\n\t        // calculate angle between last and current vectors (positive angle counter-clockwise)\n\t        var angle = Math.atan2(lastVector[0] * newVector[1] - newVector[0] * lastVector[1], lastVector[0] * newVector[0] + lastVector[1] * newVector[1]);\n\t\n\t        this.setAngle(this.getAngle() + angle);\n\t        this.dispatchRotatingEvent_(this.features_);\n\t\n\t        this.lastCoordinate_ = evt.coordinate;\n\t    }\n\t    // handle drag of the anchor\n\t    else if (this.anchorMoving_) {\n\t            this.setAnchor(newCoordinate);\n\t        }\n\t}\n\t\n\t/**\n\t * @param {ol.MapBrowserEvent} evt Event.\n\t * @return {boolean}\n\t * @this {RotateFeatureInteraction}\n\t * @private\n\t */\n\tfunction handleMoveEvent(evt) {\n\t    var elem = evt.map.getTargetElement();\n\t    var foundFeature = evt.map.forEachFeatureAtPixel(evt.pixel, function (feature) {\n\t        return feature;\n\t    });\n\t\n\t    var setCursor = function setCursor(cursor) {\n\t        var vendor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t        if (vendor) {\n\t            elem.style.cursor = '-webkit-' + cursor;\n\t            elem.style.cursor = '-moz-' + cursor;\n\t        }\n\t\n\t        elem.style.cursor = cursor;\n\t    };\n\t\n\t    if (this.lastCoordinate_) {\n\t        this.previousCursor_ = elem.style.cursor;\n\t        setCursor('grabbing', true);\n\t    } else if (foundFeature && (this.features_.getArray().includes(foundFeature) || foundFeature === this.arrowFeature_)) {\n\t        this.previousCursor_ = elem.style.cursor;\n\t        setCursor('grab', true);\n\t    } else if (foundFeature && foundFeature === this.anchorFeature_ || this.anchorMoving_) {\n\t        this.previousCursor_ = elem.style.cursor;\n\t        setCursor('crosshair');\n\t    } else {\n\t        setCursor(this.previousCursor_ || '');\n\t        this.previousCursor_ = undefined;\n\t    }\n\t}\n\t\n\t/**\n\t * @returns {ol.style.StyleFunction}\n\t * @private\n\t */\n\tfunction getDefaultStyle() {\n\t    var _styles;\n\t\n\t    var white = [255, 255, 255, 0.8];\n\t    var blue = [0, 153, 255, 0.8];\n\t    var transparent = [255, 255, 255, 0.01];\n\t    var width = 2;\n\t\n\t    var styles = (_styles = {}, _defineProperty(_styles, ANCHOR_KEY, [new _openlayers2.default.style.Style({\n\t        image: new _openlayers2.default.style.RegularShape({\n\t            fill: new _openlayers2.default.style.Fill({\n\t                color: [0, 153, 255, 0.8]\n\t            }),\n\t            stroke: new _openlayers2.default.style.Stroke({\n\t                color: blue,\n\t                width: 1\n\t            }),\n\t            radius: 4,\n\t            points: 6\n\t        }),\n\t        zIndex: Infinity\n\t    })]), _defineProperty(_styles, ARROW_KEY, [new _openlayers2.default.style.Style({\n\t        fill: new _openlayers2.default.style.Fill({\n\t            color: transparent\n\t        }),\n\t        stroke: new _openlayers2.default.style.Stroke({\n\t            color: white,\n\t            width: width + 2\n\t        }),\n\t        text: new _openlayers2.default.style.Text({\n\t            font: '12px sans-serif',\n\t            offsetX: 20,\n\t            offsetY: -20,\n\t            fill: new _openlayers2.default.style.Fill({\n\t                color: 'blue'\n\t            }),\n\t            stroke: new _openlayers2.default.style.Stroke({\n\t                color: white,\n\t                width: width + 1\n\t            })\n\t        }),\n\t        zIndex: Infinity\n\t    }), new _openlayers2.default.style.Style({\n\t        fill: new _openlayers2.default.style.Fill({\n\t            color: transparent\n\t        }),\n\t        stroke: new _openlayers2.default.style.Stroke({\n\t            color: blue,\n\t            width: width\n\t        }),\n\t        zIndex: Infinity\n\t    })]), _styles);\n\t\n\t    return function (feature, resolution) {\n\t        var style;\n\t        var angle = feature.get(ANGLE_PROP) || 0;\n\t\n\t        switch (true) {\n\t            case feature.get(ANCHOR_KEY):\n\t                style = styles[ANCHOR_KEY];\n\t                style[0].getImage().setRotation(-angle);\n\t\n\t                return style;\n\t            case feature.get(ARROW_KEY):\n\t                style = styles[ARROW_KEY];\n\t\n\t                var coordinates = feature.getGeometry().getCoordinates();\n\t                // generate arrow polygon\n\t                var geom = new _openlayers2.default.geom.Polygon([[[coordinates[0], coordinates[1] - 6 * resolution], [coordinates[0] + 8 * resolution, coordinates[1] - 12 * resolution], [coordinates[0], coordinates[1] + 30 * resolution], [coordinates[0] - 8 * resolution, coordinates[1] - 12 * resolution], [coordinates[0], coordinates[1] - 6 * resolution]]]);\n\t\n\t                // and rotate it according to current angle\n\t                geom.rotate(angle, coordinates);\n\t                style[0].setGeometry(geom);\n\t                style[1].setGeometry(geom);\n\t                style[0].getText().setText(Math.round(-angle * 180 / Math.PI) + '°');\n\t\n\t                return style;\n\t        }\n\t    };\n\t}\n\t\n\t/**\n\t * @param {ol.Collection<ol.Feature> | Array<ol.Feature>} features\n\t * @returns {ol.Extent | undefined}\n\t * @private\n\t */\n\tfunction getFeaturesExtent(features) {\n\t    if (!features.getLength()) {\n\t        return undefined;\n\t    }\n\t\n\t    return new _openlayers2.default.geom.GeometryCollection((Array.isArray(features) ? features : features.getArray()).map(function (feature) {\n\t        return feature.getGeometry();\n\t    })).getExtent();\n\t}\n\t\n\t/**\n\t * @param {ol.Collection<ol.Feature> | Array<ol.Feature>} features\n\t * @return {ol.Coordinate | undefined}\n\t */\n\tfunction getFeaturesCentroid(features) {\n\t    if (!features.getLength()) {\n\t        return undefined;\n\t    }\n\t\n\t    return _openlayers2.default.extent.getCenter(getFeaturesExtent(features));\n\t}\n\tmodule.exports = exports[\"default\"];\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\texports.assert = assert;\n\texports.assertInstanceOf = assertInstanceOf;\n\texports.noop = noop;\n\texports.identity = identity;\n\texports.getValueType = getValueType;\n\texports.coalesce = coalesce;\n\t\n\t/**\n\t * @param {boolean} condition\n\t * @param {string} message\n\t * @throws Error\n\t */\n\tfunction assert(condition) {\n\t    var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\t\n\t    message = ['Assertion failed', message].join(': ');\n\t\n\t    if (!condition) {\n\t        throw new Error(message);\n\t    }\n\t}\n\t\n\t/**\n\t * Checks if the value is an instance of the user-defined type.\n\t *\n\t * @param {*} value\n\t * @param {*} type\n\t * @throws Error\n\t */\n\tfunction assertInstanceOf(value, type) {\n\t    assert(value instanceof type, 'Expected instanceof ' + getValueType(type) + ' but got ' + getValueType(value) + '.');\n\t}\n\t\n\t/**\n\t * Null function. Do nothing.\n\t */\n\tfunction noop() {}\n\t\n\t/**\n\t * @param {*} arg\n\t * @returns {*}\n\t */\n\tfunction identity(arg) {\n\t    return arg;\n\t}\n\t\n\t/**\n\t * Returns the type of a value. If a constructor is passed, and a suitable\n\t * string cannot be found, 'unknown type name' will be returned.\n\t *\n\t * @param {*} value\n\t * @returns string\n\t */\n\tfunction getValueType(value) {\n\t    if (value instanceof Function) {\n\t        return value.name || 'unknown type name';\n\t    } else if (value instanceof Object) {\n\t        return value.constructor.name || Object.prototype.toString.call(value);\n\t    } else {\n\t        return value === null ? 'null' : typeof value === 'undefined' ? 'undefined' : _typeof(value);\n\t    }\n\t}\n\t\n\t/**\n\t * @param {...*} values\n\t * @return {*}\n\t */\n\tfunction coalesce() {\n\t    for (var _len = arguments.length, values = Array(_len), _key = 0; _key < _len; _key++) {\n\t        values[_key] = arguments[_key];\n\t    }\n\t\n\t    return values.find(function (value) {\n\t        return value != null;\n\t    });\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// bundle.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap de4fe9d7d747c6eb089c","/**\n * OpenLayers 3 rotate interaction.\n * Allows vector feature rotation.\n *\n * @author Vladimir Vershinin <ghettovoice@gmail.com>\n * @licence MIT https://opensource.org/licenses/MIT\n *          Based on OpenLayers 3. Copyright 2005-2015 OpenLayers Contributors. All rights reserved. http://openlayers.org\n * @copyright (c) 2016, Vladimir Vershinin\n */\nimport RotateFeatureInteraction from \"./RotateFeatureInteraction\";\n\nexport default RotateFeatureInteraction;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","// @flow\n/**\n * @enum {string}\n */\nexport const RotateFeatureEventType = {\n    /**\n     * Triggered upon feature rotate start.\n     * @event RotateFeatureEvent#rotatestart\n     */\n    START: 'rotatestart',\n    /**\n     * Triggered upon feature rotation.\n     * @event RotateFeatureEvent#rotating\n     */\n    ROTATING: 'rotating',\n    /**\n     * Triggered upon feature rotation end.\n     * @event RotateFeatureEvent#rotateend\n     */\n    END: 'rotateend'\n};\n\n/**\n * Events emitted by RotateFeatureInteraction instances are instances of this type.\n *\n * @class\n * @author Vladimir Vershinin\n */\nexport class RotateFeatureEvent {\n    /**\n     * @param {RotateFeatureEventType} type Type.\n     * @param {ol.Collection<ol.Feature>} features Rotated features.\n     * @param {number} angle Angle in radians.\n     * @param {ol.Coordinate} anchor Anchor position.\n     */\n    constructor(type, features, angle, anchor) {\n        /**\n         * @type {boolean}\n         */\n        this.propagationStopped = undefined;\n\n        /**\n         * The event type.\n         * @type {RotateFeatureEventType}\n         */\n        this.type = type;\n\n        /**\n         * The features being rotated.\n         * @type {ol.Collection<ol.Feature>}\n         */\n        this.features = features;\n        /**\n         * Current angle in radians.\n         * @type {number}\n         */\n        this.angle = angle;\n        /**\n         * Current rotation anchor.\n         * @type {number[] | ol.Coordinate}\n         */\n        this.anchor = anchor;\n    }\n\n    /**\n     * Stop event propagation.\n     * @function\n     */\n    preventDefault() {\n        this.propagationStopped = true;\n    }\n\n    /**\n     * Stop event propagation.\n     * @function\n     */\n    stopPropagation() {\n        this.propagationStopped = true;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/RotateFeatureEvent.js","// @flow\nimport ol from \"openlayers\";\nimport { assert, assertInstanceOf, coalesce } from \"./util\";\nimport { RotateFeatureEvent, RotateFeatureEventType } from \"./RotateFeatureEvent\";\n\n/**\n * @typedef {Object} InteractionOptions\n * @property {ol.Collection<ol.Feature>} features The features the interaction works on. Required.\n * @property {ol.style.Style | Array<ol.style.Style> | ol.style.StyleFunction | undefined} style  Style of the overlay.\n * @property {number | undefined} angle Initial angle in radians (positive is counter-clockwise),\n *                                      applied for features already added to collection. Default is `0`.\n * @property {number[] | ol.Coordinate | undefined} anchor Initial anchor coordinate. Default is center of features extent.\n */\nvar InteractionOptions;\n\nconst ANCHOR_KEY = 'anchor';\nconst ARROW_KEY = 'arrow';\n// const GHOST_KEY = 'ghost';\n\nconst ANGLE_PROP = 'angle';\nconst ANCHOR_PROP = 'anchor';\n\n/**\n * todo добавить опцию condition - для возможности переопределения клавиш\n *\n * Rotate interaction class.\n * Adds controls to rotate vector features.\n * Writes out total angle in radians (positive is counter-clockwise) to property for each feature.\n *\n * @author Vladimir Vershinin\n */\nexport default class RotateFeatureInteraction extends ol.interaction.Pointer {\n    /**\n     * @param {InteractionOptions} options\n     */\n    constructor(options : InteractionOptions = {}) {\n        super({\n            handleEvent: RotateFeatureInteraction.handleEvent,\n            handleDownEvent: handleDownEvent,\n            handleUpEvent: handleUpEvent,\n            handleDragEvent: handleDragEvent,\n            handleMoveEvent: handleMoveEvent\n        });\n\n        if (options.angle != null) {\n            this.setAngle(options.angle);\n        }\n\n        if (options.anchor != null) {\n            this.setAnchor(options.anchor);\n        }\n\n        /**\n         * @type {ol.Collection.<ol.Feature>}\n         * @private\n         */\n        this.features_ = options.features;\n\n        assertInstanceOf(this.features_, ol.Collection);\n\n        /**\n         * @type {ol.layer.Vector}\n         * @private\n         */\n        this.overlay_ = new ol.layer.Vector({\n            style: options.style || getDefaultStyle(),\n            source: new ol.source.Vector({\n                features: new ol.Collection()\n            })\n        });\n        /**\n         * @type {string}\n         * @private\n         */\n        this.previousCursor_ = undefined;\n//        /**\n//         * Rotated feature.\n//         *\n//         * @type {ol.Feature}\n//         * @private\n//         */\n//        this.ghostFeature_ = undefined;\n        /**\n         * @type {ol.Feature}\n         * @private\n         */\n        this.anchorFeature_ = undefined;\n        /**\n         * @type {ol.Feature}\n         * @private\n         */\n        this.arrowFeature_ = undefined;\n        /**\n         * @type {ol.Coordinate}\n         * @private\n         */\n        this.lastCoordinate_ = undefined;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.anchorMoving_ = false;\n\n        this.features_.on('add', this.onFeatureAdd_, this);\n        this.features_.on('remove', this.onFeatureRemove_, this);\n\n        this.on('change:active', this.onChangeActive_, this);\n        this.on('change:' + ANGLE_PROP, this.onAngleChange_, this);\n        this.on('change:' + ANCHOR_PROP, this.onAnchorChange_, this);\n    }\n\n    /**\n     * @param {ol.MapBrowserEvent} evt Map browser event.\n     * @return {boolean} `false` to stop event propagation.\n     * @this {RotateFeatureInteraction}\n     * @public\n     */\n    static handleEvent(evt : ol.MapBrowserEvent) : boolean {\n        // disable selection of inner features\n        const foundFeature = evt.map.forEachFeatureAtPixel(evt.pixel, feature => feature);\n        if (\n            [ 'click', 'singleclick' ].includes(evt.type) &&\n            foundFeature && [this.anchorFeature_, this.arrowFeature_].includes(foundFeature)\n        ) {\n            return false;\n        }\n\n        return ol.interaction.Pointer.handleEvent.call(this, evt);\n    }\n\n    //noinspection JSUnusedGlobalSymbols\n    /**\n     * @param {ol.Map} map\n     */\n    setMap(map) {\n        this.overlay_.setMap(map);\n        super.setMap(map);\n\n        if (map) {\n            this.updateInteractionFeatures_();\n        } else {\n            this.reset_(true);\n        }\n    }\n\n    /**\n     * @private\n     */\n    onChangeActive_() {\n        if (this.getActive()) {\n            this.updateInteractionFeatures_();\n        } else {\n            this.reset_(true);\n        }\n    }\n\n    /**\n     * Set current angle of interaction features.\n     *\n     * @param {number} angle\n     */\n    setAngle(angle : number) {\n        assert(!isNaN(parseFloat(angle)), 'Numeric value passed');\n\n        this.set(ANGLE_PROP, parseFloat(angle));\n    }\n\n    /**\n     * Returns current angle of interaction features.\n     *\n     * @return {number}\n     */\n    getAngle() : number {\n        return coalesce(this.get(ANGLE_PROP), 0);\n    }\n\n    /**\n     * Set current anchor position.\n     *\n     * @param {number[] | ol.Coordinate | undefined} anchor\n     */\n    setAnchor(anchor? : ol.Coordinate) {\n        assert(anchor == null || Array.isArray(anchor) && anchor.length === 2, 'Array of two elements passed');\n        this.set(ANCHOR_PROP, anchor != null ? anchor.map(parseFloat) : undefined);\n    }\n\n    /**\n     * Returns current anchor position.\n     *\n     * @return {number[] | ol.Coordinate | undefined}\n     */\n    getAnchor() : ol.Coordinate {\n        return coalesce(this.get(ANCHOR_PROP), getFeaturesCentroid(this.features_));\n    }\n\n    /**\n     * Creates or updates all interaction helper features.\n     * @private\n     */\n    updateInteractionFeatures_() {\n        if (!this.features_.getLength()) {\n            this.reset_();\n\n            return;\n        }\n\n        this.createOrUpdateAnchorFeature_();\n        this.createOrUpdateArrowFeature_();\n    }\n\n    /**\n     * @param {boolean} [resetAngleAndAnchor]\n     * @private\n     */\n    reset_(resetAngleAndAnchor = false) {\n        if (resetAngleAndAnchor) {\n            this.resetAngleAndAnchor_();\n        }\n\n        [this.anchorFeature_, this.arrowFeature_].forEach(feature => {\n            if (feature) {\n                this.overlay_.getSource().removeFeature(feature);\n            }\n        });\n\n        this.anchorFeature_ = this.arrowFeature_ =\n            this.lastCoordinate_ = undefined;\n        this.anchorMoving_ = false;\n    }\n\n    /**\n     * @private\n     */\n    resetAngleAndAnchor_() {\n        this.resetAngle_();\n        this.resetAnchor_();\n    }\n\n    /**\n     * @private\n     */\n    resetAngle_() {\n        this.set(ANGLE_PROP, 0, true);\n        this.arrowFeature_ && this.arrowFeature_.set(ANGLE_PROP, this.getAngle());\n        this.anchorFeature_ && this.anchorFeature_.set(ANGLE_PROP, this.getAngle());\n    }\n\n    /**\n     * @private\n     */\n    resetAnchor_() {\n        this.set(ANCHOR_PROP, getFeaturesCentroid(this.features_), true);\n\n        if (this.getAnchor()) {\n            this.arrowFeature_ && this.arrowFeature_.getGeometry().setCoordinates(this.getAnchor());\n            this.anchorFeature_ && this.anchorFeature_.getGeometry().setCoordinates(this.getAnchor());\n        }\n    }\n\n    /**\n     * @private\n     */\n    createOrUpdateAnchorFeature_() {\n        const angle = this.getAngle();\n        const anchor = this.getAnchor();\n\n        if (this.anchorFeature_) {\n            this.anchorFeature_.getGeometry().setCoordinates(anchor);\n        } else {\n            this.anchorFeature_ = new ol.Feature({\n                geometry: new ol.geom.Point(anchor),\n                [ANCHOR_KEY]: true,\n                [ANGLE_PROP]: angle\n            });\n            this.overlay_.getSource().addFeature(this.anchorFeature_);\n        }\n    }\n\n//    /**\n//     * @private\n//     */\n//    createOrUpdateGhostFeature_() {\n//        if (this.ghostFeature_) {\n//            this.ghostFeature_.getGeometry().setGeometries(geometries);\n//        } else {\n//            this.ghostFeature_ = new ol.Feature({\n//                geometry: new ol.geom.GeometryCollection(geometries),\n//                [GHOST_KEY]: true\n//            });\n//            this.overlay_.addFeature(this.ghostFeature_);\n//        }\n//    }\n\n    /**\n     * @private\n     */\n    createOrUpdateArrowFeature_() {\n        const angle = this.getAngle();\n        const anchor = this.getAnchor();\n\n        if (this.arrowFeature_) {\n            this.arrowFeature_.getGeometry().setCoordinates(anchor);\n        } else {\n            this.arrowFeature_ = new ol.Feature({\n                geometry: new ol.geom.Point(anchor),\n                [ARROW_KEY]: true,\n                [ANGLE_PROP]: angle\n            });\n            this.overlay_.getSource().addFeature(this.arrowFeature_);\n        }\n    }\n\n    /**\n     * @param {ol.Feature} element\n     * @private\n     */\n    onFeatureAdd_({ element }) {\n        if (!this.getActive()) {\n            return;\n        }\n\n        assertInstanceOf(element, ol.Feature);\n\n        this.resetAngleAndAnchor_();\n        this.updateInteractionFeatures_();\n    }\n\n    /**\n     * @param {ol.Feature} element\n     * @private\n     */\n    onFeatureRemove_({ element }) {\n        if (!this.getActive()) {\n            return;\n        }\n\n        assertInstanceOf(element, ol.Feature);\n\n        this.resetAngleAndAnchor_();\n        this.updateInteractionFeatures_();\n    }\n\n    /**\n     * @private\n     */\n    onAngleChange_({ oldValue }) {\n        this.features_.forEach(feature => feature.getGeometry().rotate(this.getAngle() - oldValue, this.anchorFeature_.getGeometry().getCoordinates()));\n        this.arrowFeature_ && this.arrowFeature_.set(ANGLE_PROP, this.getAngle());\n        this.anchorFeature_ && this.anchorFeature_.set(ANGLE_PROP, this.getAngle());\n    }\n\n    /**\n     * @private\n     */\n    onAnchorChange_() {\n        const anchor = this.getAnchor();\n\n        if (anchor) {\n            this.anchorFeature_ && this.anchorFeature_.getGeometry().setCoordinates(anchor);\n            this.arrowFeature_ && this.arrowFeature_.getGeometry().setCoordinates(anchor);\n        }\n    }\n\n    /**\n     * @param {ol.Collection<ol.Feature>} features\n     * @private\n     */\n    dispatchRotateStartEvent_(features) {\n        this.dispatchEvent(\n            new RotateFeatureEvent(\n                RotateFeatureEventType.START,\n                features,\n                this.getAngle(),\n                this.getAnchor()\n            )\n        );\n    }\n\n    /**\n     * @param {ol.Collection<ol.Feature>} features\n     * @private\n     */\n    dispatchRotatingEvent_(features) {\n        this.dispatchEvent(\n            new RotateFeatureEvent(\n                RotateFeatureEventType.ROTATING,\n                features,\n                this.getAngle(),\n                this.getAnchor()\n            )\n        );\n    }\n\n    /**\n     * @param {ol.Collection<ol.Feature>} features\n     * @private\n     */\n    dispatchRotateEndEvent_(features) {\n        this.dispatchEvent(\n            new RotateFeatureEvent(\n                RotateFeatureEventType.END,\n                features,\n                this.getAngle(),\n                this.getAnchor()\n            )\n        );\n    }\n}\n\n/**\n * @param {ol.MapBrowserEvent} evt Event.\n * @return {boolean}\n * @this {RotateFeatureInteraction}\n * @private\n */\nfunction handleDownEvent(evt : ol.MapBrowserEvent) : boolean\n{\n    const foundFeature = evt.map.forEachFeatureAtPixel(evt.pixel, feature => feature);\n\n    // handle click & drag on features for rotation\n    if (\n        foundFeature && !this.lastCoordinate_ &&\n        (this.features_.getArray().includes(foundFeature) || foundFeature === this.arrowFeature_)\n    ) {\n        this.lastCoordinate_ = evt.coordinate;\n\n        handleMoveEvent.call(this, evt);\n        this.dispatchRotateStartEvent_(this.features_);\n\n        return true;\n    }\n    // handle click & drag on rotation anchor feature\n    else if (foundFeature && foundFeature === this.anchorFeature_) {\n        this.anchorMoving_ = true;\n        handleMoveEvent.call(this, evt);\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * @param {ol.MapBrowserEvent} evt Event.\n * @return {boolean}\n * @this {RotateFeatureInteraction}\n * @private\n */\nfunction handleUpEvent(evt : ol.MapBrowserEvent) : boolean\n{\n    // stop drag sequence of features\n    if (this.lastCoordinate_) {\n        this.lastCoordinate_ = undefined;\n\n        handleMoveEvent.call(this, evt);\n        this.dispatchRotateEndEvent_(this.features_);\n\n        return true;\n    }\n    // stop drag sequence of the anchors\n    else if (this.anchorMoving_) {\n        this.anchorMoving_ = false;\n        handleMoveEvent.call(this, evt);\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * @param {ol.MapBrowserEvent} evt Event.\n * @return {boolean}\n * @this {RotateFeatureInteraction}\n * @private\n */\nfunction handleDragEvent(evt : ol.MapBrowserEvent) : boolean\n{\n    const newCoordinate = evt.coordinate;\n    const anchorCoordinate = this.anchorFeature_.getGeometry().getCoordinates();\n\n    // handle drag of features by angle\n    if (this.lastCoordinate_) {\n        // calculate vectors of last and current pointer positions\n        const lastVector = [this.lastCoordinate_[0] - anchorCoordinate[0], this.lastCoordinate_[1] - anchorCoordinate[1]];\n        const newVector = [newCoordinate[0] - anchorCoordinate[0], newCoordinate[1] - anchorCoordinate[1]];\n\n        // calculate angle between last and current vectors (positive angle counter-clockwise)\n        let angle = Math.atan2(lastVector[0] * newVector[1] - newVector[0] * lastVector[1], lastVector[0] * newVector[0] + lastVector[1] * newVector[1]);\n\n        this.setAngle(this.getAngle() + angle);\n        this.dispatchRotatingEvent_(this.features_);\n\n        this.lastCoordinate_ = evt.coordinate;\n    }\n    // handle drag of the anchor\n    else if (this.anchorMoving_) {\n        this.setAnchor(newCoordinate);\n    }\n}\n\n/**\n * @param {ol.MapBrowserEvent} evt Event.\n * @return {boolean}\n * @this {RotateFeatureInteraction}\n * @private\n */\nfunction handleMoveEvent(evt : ol.MapBrowserEvent) : boolean\n{\n    const elem = evt.map.getTargetElement();\n    const foundFeature = evt.map.forEachFeatureAtPixel(evt.pixel, feature => feature);\n\n    const setCursor = (cursor, vendor = false) => {\n        if (vendor) {\n            elem.style.cursor = '-webkit-' + cursor;\n            elem.style.cursor = '-moz-' + cursor;\n        }\n\n        elem.style.cursor = cursor;\n    };\n\n    if (this.lastCoordinate_) {\n        this.previousCursor_ = elem.style.cursor;\n        setCursor('grabbing', true);\n    } else if (foundFeature && (this.features_.getArray().includes(foundFeature) || foundFeature === this.arrowFeature_)) {\n        this.previousCursor_ = elem.style.cursor;\n        setCursor('grab', true);\n    } else if (foundFeature && foundFeature === this.anchorFeature_ || this.anchorMoving_) {\n        this.previousCursor_ = elem.style.cursor;\n        setCursor('crosshair');\n    } else {\n        setCursor(this.previousCursor_ || '');\n        this.previousCursor_ = undefined;\n    }\n}\n\n/**\n * @returns {ol.style.StyleFunction}\n * @private\n */\nfunction getDefaultStyle() : ol.style.StyleFunction\n{\n    const white = [255, 255, 255, 0.8];\n    const blue = [0, 153, 255, 0.8];\n    const transparent = [255, 255, 255, 0.01];\n    const width = 2;\n\n    const styles = {\n        [ANCHOR_KEY]: [\n            new ol.style.Style({\n                image: new ol.style.RegularShape({\n                    fill: new ol.style.Fill({\n                        color: [0, 153, 255, 0.8]\n                    }),\n                    stroke: new ol.style.Stroke({\n                        color: blue,\n                        width: 1\n                    }),\n                    radius: 4,\n                    points: 6\n                }),\n                zIndex: Infinity\n            })\n        ],\n        [ARROW_KEY]: [\n            new ol.style.Style({\n                fill: new ol.style.Fill({\n                    color: transparent\n                }),\n                stroke: new ol.style.Stroke({\n                    color: white,\n                    width: width + 2\n                }),\n                text: new ol.style.Text({\n                    font: '12px sans-serif',\n                    offsetX: 20,\n                    offsetY: -20,\n                    fill: new ol.style.Fill({\n                        color: 'blue'\n                    }),\n                    stroke: new ol.style.Stroke({\n                        color: white,\n                        width: width + 1\n                    })\n                }),\n                zIndex: Infinity\n            }),\n            new ol.style.Style({\n                fill: new ol.style.Fill({\n                    color: transparent\n                }),\n                stroke: new ol.style.Stroke({\n                    color: blue,\n                    width\n                }),\n                zIndex: Infinity\n            })\n        ]\n    };\n\n    return function (feature, resolution) {\n        var style;\n        const angle = feature.get(ANGLE_PROP) || 0;\n\n        switch (true) {\n            case feature.get(ANCHOR_KEY):\n                style = styles[ANCHOR_KEY];\n                style[0].getImage().setRotation(-angle);\n\n                return style;\n            case feature.get(ARROW_KEY):\n                style = styles[ARROW_KEY];\n\n                const coordinates = feature.getGeometry().getCoordinates();\n                // generate arrow polygon\n                const geom = new ol.geom.Polygon([\n                    [\n                        [coordinates[0], coordinates[1] - 6 * resolution],\n                        [coordinates[0] + 8 * resolution, coordinates[1] - 12 * resolution],\n                        [coordinates[0], coordinates[1] + 30 * resolution],\n                        [coordinates[0] - 8 * resolution, coordinates[1] - 12 * resolution],\n                        [coordinates[0], coordinates[1] - 6 * resolution],\n                    ]\n                ]);\n\n                // and rotate it according to current angle\n                geom.rotate(angle, coordinates);\n                style[0].setGeometry(geom);\n                style[1].setGeometry(geom);\n                style[0].getText().setText(Math.round(-angle * 180 / Math.PI) + '°');\n\n                return style;\n        }\n    };\n}\n\n/**\n * @param {ol.Collection<ol.Feature> | Array<ol.Feature>} features\n * @returns {ol.Extent | undefined}\n * @private\n */\nfunction getFeaturesExtent(features : ol.Collection<ol.Feature> | Array<ol.Feature>) : ol.Extent\n{\n    if (!features.getLength()) {\n        return undefined;\n    }\n\n    return new ol.geom.GeometryCollection(\n        ( Array.isArray(features) ? features : features.getArray() ).map(feature => feature.getGeometry())\n    ).getExtent();\n}\n\n/**\n * @param {ol.Collection<ol.Feature> | Array<ol.Feature>} features\n * @return {ol.Coordinate | undefined}\n */\nfunction getFeaturesCentroid(features : ol.Collection<ol.Feature> | Array<ol.Feature>) : ol.Coordinate\n{\n    if (!features.getLength()) {\n        return undefined;\n    }\n\n    return ol.extent.getCenter(getFeaturesExtent(features));\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/RotateFeatureInteraction.js","// @flow\n/**\n * @param {boolean} condition\n * @param {string} message\n * @throws Error\n */\nexport function assert(condition:boolean, message = '') {\n    message = ['Assertion failed', message].join(': ');\n\n    if (!condition) {\n        throw new Error(message);\n    }\n}\n\n/**\n * Checks if the value is an instance of the user-defined type.\n *\n * @param {*} value\n * @param {*} type\n * @throws Error\n */\nexport function assertInstanceOf(value, type) {\n    assert(value instanceof type, `Expected instanceof ${getValueType(type)} but got ${getValueType(value)}.`);\n}\n\n/**\n * Null function. Do nothing.\n */\nexport function noop() {}\n\n/**\n * @param {*} arg\n * @returns {*}\n */\nexport function identity(arg) {\n    return arg;\n}\n\n/**\n * Returns the type of a value. If a constructor is passed, and a suitable\n * string cannot be found, 'unknown type name' will be returned.\n *\n * @param {*} value\n * @returns string\n */\nexport function getValueType(value) : string {\n    if (value instanceof Function) {\n        return value.name || 'unknown type name';\n    } else if (value instanceof Object) {\n        return value.constructor.name || Object.prototype.toString.call(value);\n    } else {\n        return value === null ? 'null' : typeof value;\n    }\n}\n\n/**\n * @param {...*} values\n * @return {*}\n */\nexport function coalesce(...values) {\n    return values.find(value => value != null);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/util.js","module.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"ol\",\"amd\":\"openlayers\",\"commonjs\":\"openlayers\",\"commonjs2\":\"openlayers\"}\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}